{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment Trabalho 2  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2.0 \par
}}Trabalho 2}
{\comment Gerado porDoxgyen. }
{\creatim \yr2018\mo9\dy23\hr23\min51\sec10}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Trabalho 2}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 2.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Domingo, 23 de Setembro de 2018 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Simulador Assembly Mips{\tc \v Simulador Assembly Mips}\par \pard\plain 
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Os arquivos est\'E3o organizados da seguinte forma:} \par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
docs -> Cont\'E9m os arquivos de documenta\'E7\'E3o gerados pelo doxygen (Latex e Html) e os relat\'F3rios individuais de cada membro do grupo\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
include-> Cont\'E9m os arquivos de cabe\'E7alho do c\'F3digo como (.h)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
obj-> Cont\'E9m os objetos e arquivos gcov gerados pelo makefile\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src-> Cont\'E9m as fun\'E7\'F5es dos arquivos de cabe\'E7alho, a main e o makefile\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lib-> Cont\'E9m os arquivos bin\'E1rios para rodar o programa {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par}
{\b Ambiente e Execu\'E7\'E3o} \par
{\b Requirements:}  {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Ubuntu version: 18:04\par
gcc version: 7.3.0\par
make version: 4.1\par
}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Caso necess\'E1rio, instale os pacotes utilizando "sudo apt-get install make""\par}
{\b Para compilar e executar: Acesse o diret\'F3rio "src"} \par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Para compilar digite "make" e o projeto ser\'E1 compilado.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Para executar (somente se projeto j\'E1 tiver sido compilado) digite "make project" e o arquivo "Project" ser\'E1 gerado na estrutura principal.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Para compilar e executar automaticamente digite "make all" no terminal e o arquivo "Project" ser\'E1 gerado na estrutura principal do projeto e executado automaticamente\par}
{\b Comandos makefile:}  {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid make         -  Compila o Projeto\par
make project     -  Executa o projeto\par
make clean   -  Apaga arquivos objeto, bin\'E1rios, gcov e outros\par
make all     -  Compila, executa e gera Arquivos Gcov\par
}
\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\b Observa\'E7\'F5es:} \par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Na main, \'E9 poss\'EDvel alterar a vari\'E1vel DEBUG para true, ou para false, para debugar o c\'F3digo, mostrando informa\'E7\'F5es \'FAteis.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Na main, tamb\'E9m \'E9 poss\'EDvel alterar o diret\'F3rio em que o programa deve procurar os arquivos bin\'E1rios "text.bin e data.bin". Por padr\'E3o, o programa procura dentro da pasta lib. Ex:\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strcpy(DIR, "teste") - procura arquivos text.bin e data.bin no diret\'F3rio /lib/teste\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strcpy(DIR, "primos") - procura arquivos text.bin e data.bin no diret\'F3rio /lib/primos \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos componentes\par \pard\plain 
{\tc \v \'CDndice dos componentes}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de componentes\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de classes, estruturas, uni\'F5es e interfaces com uma breve descri\'E7\'E3o:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b int26_t} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo uint26_t })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b uint5_t} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint5_t} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b uint6_t} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint6_t} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos ficheiros\par \pard\plain 
{\tc \v \'CDndice dos ficheiros}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de ficheiros\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de todos os ficheiros com uma breve descri\'E7\'E3o:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b memory/include/{\b global.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/include/{\b init.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/include/{\b memory.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/include/{\b recorder.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/src/{\b global.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/src/{\b init.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/src/{\b main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/src/{\b memory.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b memory/src/{\b recorder.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documenta\'E7\'E3o da classe{\tc \v Documenta\'E7\'E3o da classe}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura int26_t\par \pard\plain 
{\tc\tcl2 \v int26_t}
{\xe \v int26_t}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo uint26_t. }}\par
{
{\f2 #include <global.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b value}: 26\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo uint26_t. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
O tipo uint26_t \'E9 definido como um tipo que cont\'E9m uma vari\'E1vel unsigned int value de 26 bits \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v value\:int26_t}
{\xe \v int26_t\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int int26_t::value}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
memory/include/{\b global.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura uint5_t\par \pard\plain 
{\tc\tcl2 \v uint5_t}
{\xe \v uint5_t}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint5_t}. }}\par
{
{\f2 #include <global.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b value}: 5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint5_t}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
O tipo {\b uint5_t} \'E9 definido como um tipo que cont\'E9m uma vari\'E1vel unsigned int value de 5 bits \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v value\:uint5_t}
{\xe \v uint5_t\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int uint5_t::value}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
memory/include/{\b global.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia \'E0 estrutura uint6_t\par \pard\plain 
{\tc\tcl2 \v uint6_t}
{\xe \v uint6_t}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint6_t}. }}\par
{
{\f2 #include <global.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos P\'FAblicos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b value}: 6\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descri\'E7\'E3o detalhada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint6_t}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
O tipo {\b uint6_t} \'E9 definido como um tipo que cont\'E9m uma vari\'E1vel unsigned int value de 6 bits \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos dados membro\par
\pard\plain 
{\xe \v value\:uint6_t}
{\xe \v uint6_t\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int uint6_t::value}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
A documenta\'E7\'E3o para esta estrutura foi gerada a partir do seguinte ficheiro:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
memory/include/{\b global.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documenta\'E7\'E3o do ficheiro{\tc \v Documenta\'E7\'E3o do ficheiro}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/include/global.h\par \pard\plain 
{\tc\tcl2 \v memory/include/global.h}
{\xe \v memory/include/global.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Componentes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b uint5_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint5_t}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b uint6_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint6_t}. }\par}}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b int26_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo uint26_t. }\par}}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEM_SIZE}\~ 4096\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defini\'E7\'F5es de tipos\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b uint5_t} {\b uint5_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint5_t}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b uint6_t} {\b uint6_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint6_t}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b int26_t} {\b int26_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo uint26_t. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumera\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b OPCODES} \{ {\b EXT} = 0x00, 
{\b J} = 0x02, 
{\b JAL} = 0x03, 
{\b BEQ} = 0x04, 
{\b BNE} = 0x05, 
{\b BLEZ} = 0x06, 
{\b BGTZ} = 0x07, 
{\b ADDI} = 0x08, 
{\b ADDIU} = 0x09, 
{\b SLTI} = 0x0A, 
{\b SLTIU} = 0x0B, 
{\b ANDI} = 0x0C, 
{\b ORI} = 0x0D, 
{\b XORI} = 0x0E, 
{\b LUI} = 0x0F, 
{\b LB} = 0x20, 
{\b LH} = 0x21, 
{\b LW} = 0x23, 
{\b LBU} = 0x24, 
{\b LHU} = 0x25, 
{\b SB} = 0x28, 
{\b SH} = 0x29, 
{\b SW} = 0x2B
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opcodes assembly MIPS, e suas respectivas instru\'E7\'F5es. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FUNCT} \{ {\b SLL} = 0x00, 
{\b SRL} = 0x02, 
{\b SRA} = 0x03, 
{\b JR} = 0x08, 
{\b SYSCALL} = 0x0C, 
{\b MFHI} = 0x10, 
{\b MFLO} = 0x12, 
{\b MULT} = 0x18, 
{\b DIV} = 0x1A, 
{\b ADD} = 0x20, 
{\b ADDU} = 0x21, 
{\b SUB} = 0x22, 
{\b AND} = 0x24, 
{\b OR} = 0x25, 
{\b XOR} = 0x26, 
{\b NOR} = 0x27, 
{\b SLT} = 0x2A, 
{\b SLTU} = 0x2B
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funct do assembly MIPS, e suas respectivas instru\'E7\'F5es. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b bool} \{ {\b false}, 
{\b true}
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum que define o tipo bool. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que chama as fun\'E7\'F5es de depura\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug_opcode} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es uteis das instru\'E7\'F5es de opcode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug_funct} (int)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es \'FAteis de funct. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Vari\'E1veis\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint5_t} {\b rs}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vari\'E1veis globais. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint5_t} {\b rt}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint5_t} {\b rd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint5_t} {\b shamt}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint6_t} {\b op}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint6_t} {\b funct}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b k16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int26_t} {\b k26}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b pc}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ri}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b hi}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b epc}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b mem} [{\b MEM_SIZE}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b reg} [32]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b bool} {\b DEBUG}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b counter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b DIR} [100]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das macros\par
\pard\plain 
{\xe \v MEM_SIZE\:global.h}
{\xe \v global.h\:MEM_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEM_SIZE\~ 4096}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos tipos\par
\pard\plain 
{\xe \v int26_t\:global.h}
{\xe \v global.h\:int26_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b int26_t}  {\b int26_t}}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo uint26_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
O tipo uint26_t \'E9 definido como um tipo que cont\'E9m uma vari\'E1vel unsigned int value de 26 bits \par
}}
{\xe \v uint5_t\:global.h}
{\xe \v global.h\:uint5_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b uint5_t}  {\b uint5_t}}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint5_t}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
O tipo {\b uint5_t} \'E9 definido como um tipo que cont\'E9m uma vari\'E1vel unsigned int value de 5 bits \par
}}
{\xe \v uint6_t\:global.h}
{\xe \v global.h\:uint6_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b uint6_t}  {\b uint6_t}}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct que define o tipo {\b uint6_t}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
O tipo {\b uint6_t} \'E9 definido como um tipo que cont\'E9m uma vari\'E1vel unsigned int value de 6 bits \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o dos valores da enumera\'E7\'E3o\par
\pard\plain 
{\xe \v bool\:global.h}
{\xe \v global.h\:bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b bool}}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enum que define o tipo bool. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Como o tipo bool n\'E3o existe em C99, houve a necessidade de criar um enum que representasse esse tipo \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumera\'E7\'F5es:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v false\:global.h}
{\xe \v global.h\:false}
{\qr false{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\cell }{\cell }{\row }
{\xe \v true\:global.h}
{\xe \v global.h\:true}
{\qr true{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    98 \{\par
   99     false,\par
  100     true\par
  101 \} bool;\par
}
}
{\xe \v FUNCT\:global.h}
{\xe \v global.h\:FUNCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b FUNCT}}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funct do assembly MIPS, e suas respectivas instru\'E7\'F5es. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cada Funct descrito neste enum, representa uma instru\'E7\'E3o no assembly MIPS \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumera\'E7\'F5es:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v SLL\:global.h}
{\xe \v global.h\:SLL}
{\qr SLL{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\cell }{\cell }{\row }
{\xe \v SRL\:global.h}
{\xe \v global.h\:SRL}
{\qr SRL{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\cell }{\cell }{\row }
{\xe \v SRA\:global.h}
{\xe \v global.h\:SRA}
{\qr SRA{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
\cell }{\cell }{\row }
{\xe \v JR\:global.h}
{\xe \v global.h\:JR}
{\qr JR{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\cell }{\cell }{\row }
{\xe \v SYSCALL\:global.h}
{\xe \v global.h\:SYSCALL}
{\qr SYSCALL{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\cell }{\cell }{\row }
{\xe \v MFHI\:global.h}
{\xe \v global.h\:MFHI}
{\qr MFHI{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\cell }{\cell }{\row }
{\xe \v MFLO\:global.h}
{\xe \v global.h\:MFLO}
{\qr MFLO{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\cell }{\cell }{\row }
{\xe \v MULT\:global.h}
{\xe \v global.h\:MULT}
{\qr MULT{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
\cell }{\cell }{\row }
{\xe \v DIV\:global.h}
{\xe \v global.h\:DIV}
{\qr DIV{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
\cell }{\cell }{\row }
{\xe \v ADD\:global.h}
{\xe \v global.h\:ADD}
{\qr ADD{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
\cell }{\cell }{\row }
{\xe \v ADDU\:global.h}
{\xe \v global.h\:ADDU}
{\qr ADDU{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
\cell }{\cell }{\row }
{\xe \v SUB\:global.h}
{\xe \v global.h\:SUB}
{\qr SUB{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
\cell }{\cell }{\row }
{\xe \v AND\:global.h}
{\xe \v global.h\:AND}
{\qr AND{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\cell }{\cell }{\row }
{\xe \v OR\:global.h}
{\xe \v global.h\:OR}
{\qr OR{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\cell }{\cell }{\row }
{\xe \v XOR\:global.h}
{\xe \v global.h\:XOR}
{\qr XOR{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\cell }{\cell }{\row }
{\xe \v NOR\:global.h}
{\xe \v global.h\:NOR}
{\qr NOR{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\cell }{\cell }{\row }
{\xe \v SLT\:global.h}
{\xe \v global.h\:SLT}
{\qr SLT{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\cell }{\cell }{\row }
{\xe \v SLTU\:global.h}
{\xe \v global.h\:SLTU}
{\qr SLTU{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    45 \{\par
   46     SLL = 0x00,\par
   47     SRL = 0x02,\par
   48     SRA = 0x03,\par
   49     JR = 0x08,\par
   50     SYSCALL = 0x0C,\par
   51     MFHI = 0x10,\par
   52     MFLO = 0x12,\par
   53     MULT = 0x18,\par
   54     DIV = 0x1A,\par
   55     ADD = 0x20,\par
   56     ADDU = 0x21,\par
   57     SUB = 0x22,\par
   58     AND = 0x24,\par
   59     OR = 0x25,\par
   60     XOR = 0x26,\par
   61     NOR = 0x27,\par
   62     SLT = 0x2A,\par
   63     SLTU = 0x2B,\par
   64 \};\par
}
}
{\xe \v OPCODES\:global.h}
{\xe \v global.h\:OPCODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b OPCODES}}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Opcodes assembly MIPS, e suas respectivas instru\'E7\'F5es. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cada Opcode descrito neste enum, representa uma instru\'E7\'E3o no assembly MIPS \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumera\'E7\'F5es:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v EXT\:global.h}
{\xe \v global.h\:EXT}
{\qr EXT{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\cell }{\cell }{\row }
{\xe \v J\:global.h}
{\xe \v global.h\:J}
{\qr J{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\cell }{\cell }{\row }
{\xe \v JAL\:global.h}
{\xe \v global.h\:JAL}
{\qr JAL{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\cell }{\cell }{\row }
{\xe \v BEQ\:global.h}
{\xe \v global.h\:BEQ}
{\qr BEQ{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\cell }{\cell }{\row }
{\xe \v BNE\:global.h}
{\xe \v global.h\:BNE}
{\qr BNE{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\cell }{\cell }{\row }
{\xe \v BLEZ\:global.h}
{\xe \v global.h\:BLEZ}
{\qr BLEZ{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\cell }{\cell }{\row }
{\xe \v BGTZ\:global.h}
{\xe \v global.h\:BGTZ}
{\qr BGTZ{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\cell }{\cell }{\row }
{\xe \v ADDI\:global.h}
{\xe \v global.h\:ADDI}
{\qr ADDI{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\cell }{\cell }{\row }
{\xe \v ADDIU\:global.h}
{\xe \v global.h\:ADDIU}
{\qr ADDIU{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\cell }{\cell }{\row }
{\xe \v SLTI\:global.h}
{\xe \v global.h\:SLTI}
{\qr SLTI{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\cell }{\cell }{\row }
{\xe \v SLTIU\:global.h}
{\xe \v global.h\:SLTIU}
{\qr SLTIU{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\cell }{\cell }{\row }
{\xe \v ANDI\:global.h}
{\xe \v global.h\:ANDI}
{\qr ANDI{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\cell }{\cell }{\row }
{\xe \v ORI\:global.h}
{\xe \v global.h\:ORI}
{\qr ORI{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\cell }{\cell }{\row }
{\xe \v XORI\:global.h}
{\xe \v global.h\:XORI}
{\qr XORI{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\cell }{\cell }{\row }
{\xe \v LUI\:global.h}
{\xe \v global.h\:LUI}
{\qr LUI{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\cell }{\cell }{\row }
{\xe \v LB\:global.h}
{\xe \v global.h\:LB}
{\qr LB{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\cell }{\cell }{\row }
{\xe \v LH\:global.h}
{\xe \v global.h\:LH}
{\qr LH{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\cell }{\cell }{\row }
{\xe \v LW\:global.h}
{\xe \v global.h\:LW}
{\qr LW{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\cell }{\cell }{\row }
{\xe \v LBU\:global.h}
{\xe \v global.h\:LBU}
{\qr LBU{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\cell }{\cell }{\row }
{\xe \v LHU\:global.h}
{\xe \v global.h\:LHU}
{\qr LHU{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\cell }{\cell }{\row }
{\xe \v SB\:global.h}
{\xe \v global.h\:SB}
{\qr SB{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\cell }{\cell }{\row }
{\xe \v SH\:global.h}
{\xe \v global.h\:SH}
{\qr SH{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\cell }{\cell }{\row }
{\xe \v SW\:global.h}
{\xe \v global.h\:SW}
{\qr SW{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
\cell }{\cell }{\row }
}
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    14 \{\par
   15     EXT = 0x00,\par
   16     J = 0x02,\par
   17     JAL = 0x03,\par
   18     BEQ = 0x04,\par
   19     BNE = 0x05,\par
   20     BLEZ = 0x06,\par
   21     BGTZ = 0x07,\par
   22     ADDI = 0x08,\par
   23     ADDIU = 0x09,\par
   24     SLTI = 0x0A,\par
   25     SLTIU = 0x0B,\par
   26     ANDI = 0x0C,\par
   27     ORI = 0x0D,\par
   28     XORI = 0x0E,\par
   29     LUI = 0x0F,\par
   30     LB = 0x20,\par
   31     LH = 0x21,\par
   32     LW = 0x23,\par
   33     LBU = 0x24,\par
   34     LHU = 0x25,\par
   35     SB = 0x28,\par
   36     SH = 0x29,\par
   37     SW = 0x2B,\par
   38 \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v debug\:global.h}
{\xe \v global.h\:debug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug (void )}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que chama as fun\'E7\'F5es de depura\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Se op for 0x00, mostra o conte\'FAdo de funct, caso contr\'E1rio, mostra o conte\'FAdo de op. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     if (DEBUG)\par
   10     \{\par
   11         if (op.value == EXT)\par
   12             debug_funct(funct.value);\par
   13         else\par
   14             debug_opcode(op.value);\par
   15 \par
   16         getchar();\par
   17     \}\par
   18 \}\par
}
}
{\xe \v debug_funct\:global.h}
{\xe \v global.h\:debug_funct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug_funct (int )}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es \'FAteis de funct. }}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     switch (instruction)\par
  121     \{\par
  122     case SLL:\par
  123         printf("sll \\t\\t [rd] = \\t d [%d] \\t\\t h [%08x]", rd.value, rd.value);\par
  124         break;\par
  125 \par
  126     case SRL:\par
  127         printf("srl \\t\\t [rd] = \\t d [%d] \\t h [%08x]", rd.value, rd.value);\par
  128         break;\par
  129 \par
  130     case SRA:\par
  131         printf("sra \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  132         break;\par
  133 \par
  134     case JR:\par
  135         printf("sra \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
  136         break;\par
  137 \par
  138     case SYSCALL:\par
  139         printf("syscall \\t reg[2] = \\t d [%d] \\t\\t h [%08x]", reg[2], reg[2]);\par
  140         break;\par
  141 \par
  142     case MFHI:\par
  143         printf("mfhi \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  144         break;\par
  145 \par
  146     case MFLO:\par
  147         printf("mflo \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  148         break;\par
  149 \par
  150     case MULT:\par
  151         printf("mult \\t\\t [hi] = \\t d [%d] \\t h [%08x]\\n", hi, hi);\par
  152         printf("mult \\t\\t [lo] = \\t d [%d] \\t h [%08x]", lo, lo);\par
  153         break;\par
  154 \par
  155     case DIV:\par
  156         printf("div \\t\\t [hi] = \\t d [%d] \\t h [%08x]\\n", hi, hi);\par
  157         printf("div \\t\\t [lo] = \\t d [%d] \\t h [%08x]", lo, lo);\par
  158         break;\par
  159 \par
  160     case ADD:\par
  161         printf("add \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  162         break;\par
  163 \par
  164     case ADDU:\par
  165         printf("addu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  166         break;\par
  167 \par
  168     case SUB:\par
  169         printf("sub \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  170         break;\par
  171 \par
  172     case AND:\par
  173         printf("and \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  174         break;\par
  175 \par
  176     case OR:\par
  177         printf("or \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  178         break;\par
  179 \par
  180     case XOR:\par
  181         printf("xor \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  182         break;\par
  183 \par
  184     case NOR:\par
  185         printf("nor \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  186         break;\par
  187 \par
  188     case SLT:\par
  189         printf("slt \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  190         break;\par
  191 \par
  192     case SLTU:\par
  193         printf("sltu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  194         break;\par
  195     \}\par
  196 \}\par
}
}
{\xe \v debug_opcode\:global.h}
{\xe \v global.h\:debug_opcode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug_opcode (int )}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es uteis das instru\'E7\'F5es de opcode. }}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23 \{\par
   24     switch (instruction)\par
   25     \{\par
   26     case J:\par
   27         printf("j \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   28         break;\par
   29 \par
   30     case JAL:\par
   31         printf("jal \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   32         break;\par
   33 \par
   34     case BEQ:\par
   35         printf("beq \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   36         break;\par
   37 \par
   38     case BNE:\par
   39         printf("bne \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   40         break;\par
   41 \par
   42     case BLEZ:\par
   43         printf("blez \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   44         break;\par
   45 \par
   46     case BGTZ:\par
   47         printf("bgtz \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   48         break;\par
   49 \par
   50     case ADDI:\par
   51         printf("addi \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   52         break;\par
   53 \par
   54     case ADDIU:\par
   55         printf("addiu \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   56         break;\par
   57 \par
   58     case SLTI:\par
   59         printf("slti \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   60         break;\par
   61 \par
   62     case SLTIU:\par
   63         printf("sltiu \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   64         break;\par
   65 \par
   66     case ANDI:\par
   67         printf("andi \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   68         break;\par
   69 \par
   70     case ORI:\par
   71         printf("ori \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   72         break;\par
   73 \par
   74     case XORI:\par
   75         printf("xori \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   76         break;\par
   77 \par
   78     case LUI:\par
   79         printf("lui \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   80         break;\par
   81 \par
   82     case LB:\par
   83         printf("lb \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   84         break;\par
   85 \par
   86     case LH:\par
   87         printf("lh \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   88         break;\par
   89 \par
   90     case LW:\par
   91         printf("lw \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   92         break;\par
   93 \par
   94     case LBU:\par
   95         printf("lbu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   96         break;\par
   97 \par
   98     case LHU:\par
   99         printf("lhu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
  100         break;\par
  101 \par
  102     case SB:\par
  103         printf("sb \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", k16, reg[rt.value], reg[rt.value]);\par
  104         break;\par
  105 \par
  106     case SH:\par
  107         printf("sh \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rs.value, reg[rs.value], reg[rs.value]);\par
  108         break;\par
  109 \par
  110     case SW:\par
  111         printf("sw \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rs.value, reg[rs.value], reg[rs.value]);\par
  112         break;\par
  113     \}\par
  114 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das vari\'E1veis\par
\pard\plain 
{\xe \v counter\:global.h}
{\xe \v global.h\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int counter}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEBUG\:global.h}
{\xe \v global.h\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b bool} DEBUG}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DIR\:global.h}
{\xe \v global.h\:DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char DIR[100]}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v epc\:global.h}
{\xe \v global.h\:epc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t epc}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v funct\:global.h}
{\xe \v global.h\:funct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint6_t} funct}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v hi\:global.h}
{\xe \v global.h\:hi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t hi}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v k16\:global.h}
{\xe \v global.h\:k16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t k16}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v k26\:global.h}
{\xe \v global.h\:k26}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b int26_t} k26}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lo\:global.h}
{\xe \v global.h\:lo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lo}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mem\:global.h}
{\xe \v global.h\:mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t mem[{\b MEM_SIZE}]}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v op\:global.h}
{\xe \v global.h\:op}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint6_t} op}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pc\:global.h}
{\xe \v global.h\:pc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t pc}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rd\:global.h}
{\xe \v global.h\:rd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint5_t} rd}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reg\:global.h}
{\xe \v global.h\:reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t reg[32]}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ri\:global.h}
{\xe \v global.h\:ri}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ri}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rs\:global.h}
{\xe \v global.h\:rs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint5_t} rs}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vari\'E1veis globais. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Como s\'E3o utilizadas muitas vari\'E1veis globais no projeto, houve a necessidade de criar um bloco de c\'F3digo que contesse todas as defini\'E7\'F5es desses tipos de vari\'E1veis \par
}}
{\xe \v rt\:global.h}
{\xe \v global.h\:rt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint5_t} rt}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shamt\:global.h}
{\xe \v global.h\:shamt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint5_t} shamt}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/include/init.h\par \pard\plain 
{\tc\tcl2 \v memory/include/init.h}
{\xe \v memory/include/init.h}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include "memory.h"}\par
{\f2 #include "global.h"}\par
{\f2 #include "recorder.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializa\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_variables} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializador de Vari\'E1veis. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_values} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_data} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de data.bin. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_text} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de text.bin. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v init\:init.h}
{\xe \v init.h\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init (void )}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializa\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui s\'E3o definidos os cabe\'E7alhos de todas as fun\'E7\'F5es de inicializa\'E7\'E3o, tais como setar o valor inicial das vari\'E1veis, ler os arquivos text.bin e data.bin\par
Inicializa\'E7\'E3o.\par
Chama todas as fun\'E7\'F5es de inicializa\'E7\'E3o, que inicializam vari\'E1veis e leem os arquivos text.bin e data.bin. Se DEBUG for true, ele mostra informa\'E7\'F5es dos registradores e da mem\'F3ria {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     init_variables();\par
   14     read_data();\par
   15     read_text();\par
   16     run();\par
   17 \par
   18     if (DEBUG)\par
   19     \{\par
   20         dump_reg('h');\par
   21         dump_reg('d');\par
   22         dump_mem_recorder(0, 72, 'h');\par
   23         printf("\\n");\par
   24         dump_mem_recorder(0, 72, 'd');\par
   25     \}\par
   26 \}\par
}
}
{\xe \v init_variables\:init.h}
{\xe \v init.h\:init_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_variables (void )}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializador de Vari\'E1veis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui s\'E3o setados os valores iniciais de todas as vari\'E1veis globais do projeto {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    35 \{\par
   36     int i;\par
   37 \par
   38     k16 = 0;\par
   39     k26.value = 0;\par
   40     rs.value = 0;\par
   41     rt.value = 0;\par
   42     rd.value = 0;\par
   43     shamt.value = 0;\par
   44     op.value = 0;\par
   45     funct.value = 0;\par
   46     pc = 0;\par
   47     ri = 0;\par
   48     epc = 0;\par
   49     counter = 0;\par
   50 \par
   51     for (i = 0; i < 32; i++)\par
   52         reg[i] = 0;\par
   53 \}\par
}
}
{\xe \v read_data\:init.h}
{\xe \v init.h\:read_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_data (void )}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de data.bin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA os dados do arquivo data.bin para a mem\'F3ria a partir do endere\'E7o (MEM_SIZE / 2) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    62 \{\par
   63     FILE *data;\par
   64     int i = 0;\par
   65     char lib[] = "../lib/";\par
   66     char bin[] = "/data.bin";\par
   67     char directory[200];\par
   68 \par
   69     strcpy(directory, lib);\par
   70     strcat(directory, DIR);\par
   71     strcat(directory, bin);\par
   72 \par
   73     data = fopen(directory, "rb");\par
   74 \par
   75     if (!data)\par
   76     \{\par
   77         printf("Error reading\\n");\par
   78     \}\par
   79     else\par
   80     \{\par
   81         while (fread(&mem[i + (MEM_SIZE / 2)], 4, 1, data) != 0)\par
   82         \{\par
   83             i++;\par
   84         \}\par
   85     \}\par
   86 \par
   87     fclose(data);\par
   88 \}\par
}
}
{\xe \v read_text\:init.h}
{\xe \v init.h\:read_text}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_text (void )}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de text.bin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA os dados do arquivo text.bin para a mem\'F3ria a partir do endere\'E7o 0. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    97 \{\par
   98     FILE *text;\par
   99     int i = 0;\par
  100     char lib[] = "../lib/";\par
  101     char bin[] = "/text.bin";\par
  102     char directory[200];\par
  103 \par
  104     strcpy(directory, lib);\par
  105     strcat(directory, DIR);\par
  106     strcat(directory, bin);\par
  107 \par
  108     text = fopen(directory, "rb");\par
  109 \par
  110     if (!text)\par
  111     \{\par
  112         printf("Error reading\\n");\par
  113     \}\par
  114     else\par
  115     \{\par
  116         while (fread(&mem[i], 4, 1, text) != 0)\par
  117         \{\par
  118             i++;\par
  119         \}\par
  120     \}\par
  121 \par
  122     fclose(text);\par
  123 \}\par
}
}
{\xe \v set_values\:init.h}
{\xe \v init.h\:set_values}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_values (void )}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/include/memory.h\par \pard\plain 
{\tc\tcl2 \v memory/include/memory.h}
{\xe \v memory/include/memory.h}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "global.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump_mem} (uint32_t, uint32_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b lw} (uint32_t, int16_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA uma palavra de 32 bits. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b lh} (uint32_t, int16_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lhu} (uint32_t, int16_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits sem sinal. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b lb} (uint32_t, int16_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lbu} (uint32_t, int16_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte sem sinal. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sw} (uint32_t, int16_t, int32_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva uma palavra de 32 bits na mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sh} (uint32_t, int16_t, int16_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva meia palavra de 32 bits na mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sb} (uint32_t, int16_t, int8_t)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva um byte na mem\'F3ria. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v dump_mem\:memory.h}
{\xe \v memory.h\:dump_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dump_mem (uint32_t  {\i address}, uint32_t  {\i size})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui s\'E3o definidos os cabe\'E7alhos de todas as fun\'E7\'F5es da mem\'F3ria\par
Mem\'F3ria.\par
Esta fun\'E7\'E3o mostra o conte\'FAdo da mem\'F3ria de um endere\'E7o inicial at\'E9 um endere\'E7o de valor inicial somado a uma constante. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, uint32_t size \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    11 \{\par
   12     int i;\par
   13 \par
   14     for (i = address; i < ((address + size) / 4); i++)\par
   15     \{\par
   16         printf("mem[%d] = %08x\\n", i, mem[i]);\par
   17     \}\par
   18 \}\par
}
}
{\xe \v lb\:memory.h}
{\xe \v memory.h\:lb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t lb (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler o byte Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui o byte lido \'E9 deslocado para o inicio de word\par
Aqui o byte lido \'E9 deslocado para o inicio de word\par
Aqui o byte lido \'E9 deslocado para o inicio de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   157 \{\par
  158     int32_t mask, word, rest;\par
  159 \par
  160     rest = (address + kte) % 4;\par
  161     address = (address + kte) / 4;\par
  162 \par
  163     if (rest == 0)\par
  164     \{\par
  165         mask = 0x000000ff;\par
  166         word = mem[address] & mask;\par
  167         return word;\par
  168     \}\par
  169     else if (rest == 1)\par
  170     \{\par
  171         mask = 0x0000ff00;\par
  172         word = mem[address] & mask;\par
  173 \par
  175         word >>= 4 * 2;\par
  176         return word;\par
  177     \}\par
  178     else if (rest == 2)\par
  179     \{\par
  180         mask = 0x00ff0000;\par
  181         word = mem[address] & mask;\par
  182 \par
  184         word >>= 4 * 4;\par
  185         return word;\par
  186     \}\par
  187     else if (rest == 3)\par
  188     \{\par
  189         mask = 0xff000000;\par
  190         word = mem[address] & mask;\par
  191 \par
  193         word >>= 4 * 6;\par
  194         mask = 0x000000ff;\par
  195         word &= mask;\par
  196         return word;\par
  197     \}\par
  198 \par
  199     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
  200     return 0x4552524F;\par
  201 \}\par
}
}
{\xe \v lbu\:memory.h}
{\xe \v memory.h\:lbu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lbu (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte sem sinal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler o byte Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. O valor retornado pela fun\'E7\'E3o, \'E9 um valor unsigned, ou seja, sem sinal. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui o byte lido \'E9 deslocado para o endere\'E7o inicial de word\par
Aqui o byte lido \'E9 deslocado para o endere\'E7o inicial de word\par
Aqui o byte lido \'E9 deslocado para o endere\'E7o inicial de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   215 \{\par
  216     int32_t mask, word, rest;\par
  217 \par
  218     rest = (address + kte) % 4;\par
  219     address = (address + kte) / 4;\par
  220 \par
  221     if (rest == 0)\par
  222     \{\par
  223         mask = 0x000000ff;\par
  224         word = mem[address] & mask;\par
  225         return word;\par
  226     \}\par
  227     else if (rest == 1)\par
  228     \{\par
  229         mask = 0x0000ff00;\par
  230         word = mem[address] & mask;\par
  231 \par
  233         word >>= 4 * 2;\par
  234         return word;\par
  235     \}\par
  236     else if (rest == 2)\par
  237     \{\par
  238         mask = 0x00ff0000;\par
  239         word = mem[address] & mask;\par
  240 \par
  242         word >>= 4 * 4;\par
  243         return word;\par
  244     \}\par
  245     else if (rest == 3)\par
  246     \{\par
  247         mask = 0xff000000;\par
  248         word = mem[address] & mask;\par
  249 \par
  251         word >>= 4 * 6;\par
  252         mask = 0x000000ff;\par
  253         word &= mask;\par
  254         return word;\par
  255     \}\par
  256 \par
  257     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
  258     return 0x4552524F;\par
  259 \}\par
}
}
{\xe \v lh\:memory.h}
{\xe \v memory.h\:lh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t lh (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 2, a fun\'E7\'E3o mostra uma menssagem de erro e retorna um valor que indica que h\'E1 um erro. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler meia palavra tanto superior, quanto inferior. Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui a meia palavra lida \'E9 deslocada para o endere\'E7o inicial de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{\par
   60     int32_t mask, word, rest;\par
   61 \par
   62     rest = (address + kte) % 4;\par
   63 \par
   64     if (((address + kte) % 2) == 0)\par
   65     \{\par
   66         address = (address + kte) / 4;\par
   67 \par
   68         if (rest == 0)\par
   69         \{\par
   70             mask = 0x0000ffff;\par
   71             word = mem[address] & mask;\par
   72             return word;\par
   73         \}\par
   74         else if (rest == 2)\par
   75         \{\par
   76             mask = 0xffff0000;\par
   77             word = mem[address] & mask;\par
   78 \par
   80             word >>= 4 * 4;\par
   81             mask = 0x0000ffff;\par
   82             word &= mask;\par
   83             return word;\par
   84         \}\par
   85     \}\par
   86     else\par
   87     \{\par
   88         printf("Non-aligned address\\n");\par
   89     \}\par
   90 \par
   91     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
   92     return 0x4552524F;\par
   93 \}\par
}
}
{\xe \v lhu\:memory.h}
{\xe \v memory.h\:lhu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lhu (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits sem sinal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 2, a fun\'E7\'E3o mostra uma menssagem de erro e retorna um valor que indica que h\'E1 um erro. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler meia palavra tanto superior, quanto inferior. Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. O valor retornado pela fun\'E7\'E3o, \'E9 um valor unsigned, ou seja, sem sinal. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui a meia palavra lida \'E9 deslocada para o endere\'E7o inicial de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111 \{\par
  112     uint32_t mask, word, rest;\par
  113 \par
  114     rest = (address + kte) % 4;\par
  115 \par
  116     if (((address + kte) % 2) == 0)\par
  117     \{\par
  118         address = (address + kte) / 4;\par
  119 \par
  120         if (rest == 0)\par
  121         \{\par
  122             mask = 0x0000ffff;\par
  123             word = mem[address] & mask;\par
  124             return word;\par
  125         \}\par
  126         else if (rest == 2)\par
  127         \{\par
  128             mask = 0xffff0000;\par
  129             word = mem[address] & mask;\par
  130 \par
  132             word >>= 4 * 4;\par
  133             mask = 0x0000ffff;\par
  134             word &= mask;\par
  135             return word;\par
  136         \}\par
  137     \}\par
  138     else\par
  139     \{\par
  140         printf("Non-aligned address\\n");\par
  141     \}\par
  142 \par
  143     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
  144     return 0x4552524F;\par
  145 \}\par
}
}
{\xe \v lw\:memory.h}
{\xe \v memory.h\:lw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t lw (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA uma palavra de 32 bits. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 4, a fun\'E7\'E3o mostra uma menssagem de erro e retorna um valor que indica que h\'E1 um erro. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30 \{\par
   31     if (((address + kte) % 4) == 0)\par
   32     \{\par
   33         address = (address + kte) / 4;\par
   34         return mem[address];\par
   35     \}\par
   36     else\par
   37     \{\par
   38         printf("Non-aligned address\\n");\par
   39     \}\par
   40 \par
   41     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
   42     return 0x4552524F;\par
   43 \}\par
}
}
{\xe \v sb\:memory.h}
{\xe \v memory.h\:sb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sb (uint32_t  {\i address}, int16_t  {\i kte}, int8_t  {\i dado})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva um byte na mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o de mem\'F3ria somado a uma constante. E salva o dado recebido na mem\'F3ria utilizando m\'E1scaras. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte, int32_t dado \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   332 \{\par
  333     int32_t content, mask, word, rest;\par
  334     uint32_t mask_dado;\par
  335 \par
  336     rest = (address + kte) % 4;\par
  337 \par
  338     address = (address + kte) / 4;\par
  339 \par
  340     if (rest == 0)\par
  341     \{\par
  342         mask = 0xffffff00;\par
  343         mask_dado = 0x000000ff;\par
  344         word = mem[address] & mask;\par
  345         content = dado & mask_dado;\par
  346         mem[address] = word | content;\par
  347     \}\par
  348     else if (rest == 1)\par
  349     \{\par
  350         mask = 0xffff00ff;\par
  351         mask_dado = 0x0000ff00;\par
  352         word = mem[address] & mask;\par
  353         content = (dado << 8) & mask_dado;\par
  354         mem[address] = word | content;\par
  355     \}\par
  356     else if (rest == 2)\par
  357     \{\par
  358         mask = 0xff00ffff;\par
  359         mask_dado = 0x00ff0000;\par
  360         word = mem[address] & mask;\par
  361         content = (dado << 16) & mask_dado;\par
  362         mem[address] = word | content;\par
  363     \}\par
  364     else if (rest == 3)\par
  365     \{\par
  366         mask = 0x00ffffff;\par
  367         mask_dado = 0xff000000;\par
  368         word = mem[address] & mask;\par
  369         content = (dado << 24) & mask_dado;\par
  370         mem[address] = word | content;\par
  371     \}\par
  372 \}\par
}
}
{\xe \v sh\:memory.h}
{\xe \v memory.h\:sh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sh (uint32_t  {\i address}, int16_t  {\i kte}, int16_t  {\i dado})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva meia palavra de 32 bits na mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o de mem\'F3ria somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 2, a fun\'E7\'E3o mostra uma menssagem de erro. Caso contr\'E1rio, ela salva o dado recebido na mem\'F3ria nos limites superior ou inferior do endere\'E7o utilizando m\'E1scaras. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte, int32_t dado \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int32_t content, mask, word, rest;\par
  294     uint32_t mask_dado;\par
  295 \par
  296     rest = (address + kte) % 4;\par
  297 \par
  298     if (((address + kte) % 2) == 0)\par
  299     \{\par
  300         address = (address + kte) / 4;\par
  301 \par
  302         if (rest == 0)\par
  303         \{\par
  304             mask = 0xffff0000;\par
  305             mask_dado = 0x0000ffff;\par
  306             word = mem[address] & mask;\par
  307             content = dado & mask_dado;\par
  308             mem[address] = word | content;\par
  309         \}\par
  310         else if (rest == 2)\par
  311         \{\par
  312             mask = 0x0000ffff;\par
  313             mask_dado = 0xffff0000;\par
  314             word = mem[address] & mask;\par
  315             content = (dado << 16) & mask_dado;\par
  316             mem[address] = word | content;\par
  317         \}\par
  318     \}\par
  319     else\par
  320     \{\par
  321         printf("Non-aligned address\\n");\par
  322     \}\par
  323 \}\par
}
}
{\xe \v sw\:memory.h}
{\xe \v memory.h\:sw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sw (uint32_t  {\i address}, int16_t  {\i kte}, int32_t  {\i dado})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva uma palavra de 32 bits na mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o de mem\'F3ria somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 4, a fun\'E7\'E3o mostra uma menssagem de erro. Caso contr\'E1rio, ela salva o dado recebido na mem\'F3ria {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte, int32_t dado \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270 \{\par
  271     if (((address + kte) % 4) == 0)\par
  272     \{\par
  273         address = (address + kte) / 4;\par
  274         mem[address] = dado;\par
  275     \}\par
  276     else\par
  277     \{\par
  278         printf("Non-aligned address\\n");\par
  279     \}\par
  280 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/include/recorder.h\par \pard\plain 
{\tc\tcl2 \v memory/include/recorder.h}
{\xe \v memory/include/recorder.h}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "memory.h"}\par
{\f2 #include "global.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fetch} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registrador. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decode} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que decodifica uma instru\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b execute} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que executa as instru\'E7\'F5es de opcode e funct. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b step} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA, decodifica, executa e debuga cada instru\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que roda todas as instru\'E7\'F5es da mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump_mem_recorder} (int, int, char)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra conte\'FAdo da mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump_reg} (char)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra o conte\'FAdo dos registradores. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b signal_extension} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que estende o sinal de k16. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v decode\:recorder.h}
{\xe \v recorder.h\:decode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void decode (void )}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que decodifica uma instru\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o faz uso do registrador ri, atribuindo cada parte da instru\'E7\'E3o contida em ri, em um campo \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19 \{\par
   20     op.value = (ri >> 26) & 0x3f;\par
   21     rs.value = (ri >> 21) & 0x1f;\par
   22     rt.value = (ri >> 16) & 0x1f;\par
   23     rd.value = (ri >> 11) & 0x1f;\par
   24     shamt.value = (ri >> 6) & 0x1f;\par
   25     funct.value = ri & 0x3f;\par
   26     k26.value = ri & 0x3ffffff;\par
   27     k16 = ri & 0xffff;\par
   28     signal_extension();\par
   29 \}\par
}
}
{\xe \v dump_mem_recorder\:recorder.h}
{\xe \v recorder.h\:dump_mem_recorder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dump_mem_recorder (int  {\i start}, int  {\i end}, char  {\i format})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra conte\'FAdo da mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o inicial, e um endere\'E7o final e mostra o conte\'FAdo da mem\'F3ria contido nestes endere\'E7os nos formatos hexadecimal ou decimal {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{start, int end, char format \cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315 \{\par
  316     int i;\par
  317 \par
  318     if (start < end && ((start + end) % 4) == 0)\par
  319     \{\par
  320         if (format == 'h')\par
  321         \{\par
  322             for (i = start / 4; i < end / 4; i++)\par
  323             \{\par
  324                 printf("mem[%d] =\\t\\t %08x\\n", i, mem[i]);\par
  325             \}\par
  326         \}\par
  327         else if (format == 'd')\par
  328         \{\par
  329             for (i = start / 4; i < end / 4; i++)\par
  330             \{\par
  331                 printf("mem[%d] =\\t\\t %d\\n", i, mem[i]);\par
  332             \}\par
  333         \}\par
  334         else\par
  335         \{\par
  336             printf("Invalid Format\\n");\par
  337         \}\par
  338     \}\par
  339     else\par
  340     \{\par
  341         printf("Non-aligned address\\n");\par
  342     \}\par
  343 \}\par
}
}
{\xe \v dump_reg\:recorder.h}
{\xe \v recorder.h\:dump_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dump_reg (char  {\i format})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra o conte\'FAdo dos registradores. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o percorre todos os registradores, mostrando o conte\'FAdo de cada um {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i char} \cell }{format \cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   351 \{\par
  352     int i;\par
  353 \par
  354     if (format == 'h')\par
  355     \{\par
  356         printf("\\nregister ($zero):\\t %08x\\n", reg[0]);\par
  357         printf("register ($at):\\t\\t %08x\\n", reg[1]);\par
  358         printf("register ($v0):\\t\\t %08x\\n", reg[2]);\par
  359         printf("register ($v1):\\t\\t %08x\\n", reg[3]);\par
  360 \par
  361         for (i = 4; i < 8; i++)\par
  362             printf("register ($a%d):\\t\\t %08x\\n", (i - 4), reg[i]);\par
  363         for (i = 8; i < 16; i++)\par
  364             printf("register ($t%d):\\t\\t %08x\\n", (i - 8), reg[i]);\par
  365         for (i = 16; i < 26; i++)\par
  366             printf("register ($s%d):\\t\\t %08x\\n", (i - 16), reg[i]);\par
  367 \par
  368         printf("register ($k0):\\t\\t %08x\\n", reg[26]);\par
  369         printf("register ($k1):\\t\\t %08x\\n", reg[27]);\par
  370         printf("register ($gp):\\t\\t %08x\\n", reg[28]);\par
  371         printf("register ($sp):\\t\\t %08x\\n", reg[29]);\par
  372         printf("register ($fp):\\t\\t %08x\\n", reg[30]);\par
  373         printf("register ($ra):\\t\\t %08x\\n", reg[31]);\par
  374         printf("register (pc):\\t\\t %08x\\n", pc);\par
  375         printf("register (hi):\\t\\t %08x\\n", hi);\par
  376         printf("register (lo):\\t\\t %08x\\n\\n", lo);\par
  377         printf("rs.value:\\t\\t %08x\\n", rs.value);\par
  378         printf("rt.value:\\t\\t %08x\\n", rt.value);\par
  379         printf("rd.value:\\t\\t %08x\\n", rd.value);\par
  380         printf("shamt:\\t\\t\\t %08x\\n", shamt.value);\par
  381         printf("op:\\t\\t\\t %08x\\n", op.value);\par
  382         printf("funct:\\t\\t\\t %08x\\n", funct.value);\par
  383         printf("k16:\\t\\t\\t %08x\\n", k16);\par
  384         printf("k26:\\t\\t\\t %08x\\n\\n", k26);\par
  385     \}\par
  386     else if (format == 'd')\par
  387     \{\par
  388         printf("\\nregister ($zero):\\t %d\\n", reg[0]);\par
  389         printf("register ($at):\\t\\t %d\\n", reg[1]);\par
  390         printf("register ($v0):\\t\\t %d\\n", reg[2]);\par
  391         printf("register ($v1):\\t\\t %d\\n", reg[3]);\par
  392 \par
  393         for (i = 4; i < 8; i++)\par
  394             printf("register ($a%d):\\t\\t %d\\n", (i - 4), reg[i]);\par
  395         for (i = 8; i < 16; i++)\par
  396             printf("register ($t%d):\\t\\t %d\\n", (i - 8), reg[i]);\par
  397         for (i = 16; i < 26; i++)\par
  398             printf("register ($s%d):\\t\\t %d\\n", (i - 16), reg[i]);\par
  399 \par
  400         printf("register ($k0):\\t\\t %d\\n", reg[26]);\par
  401         printf("register ($k1):\\t\\t %d\\n", reg[27]);\par
  402         printf("register ($gp):\\t\\t %d\\n", reg[28]);\par
  403         printf("register ($sp):\\t\\t %d\\n", reg[29]);\par
  404         printf("register ($fp):\\t\\t %d\\n", reg[30]);\par
  405         printf("register ($ra):\\t\\t %d\\n", reg[31]);\par
  406         printf("register (pc):\\t\\t %d\\n", pc);\par
  407         printf("register (hi):\\t\\t %d\\n", hi);\par
  408         printf("register (lo):\\t\\t %d\\n\\n", lo);\par
  409     \}\par
  410     else\par
  411     \{\par
  412         printf("Invalid Format\\n");\par
  413     \}\par
  414 \}\par
}
}
{\xe \v execute\:recorder.h}
{\xe \v recorder.h\:execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void execute (void )}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que executa as instru\'E7\'F5es de opcode e funct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depois de lidas e decodificadas as instru\'E7\'F5es do registrador de instru\'E7\'F5es (ri), os comandos opcode e funct s\'E3o avaliados e selecionados para executar os comandos da instru\'E7\'E3o \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     int64_t product;\par
   52     uint16_t kte = 0;\par
   53     int i;\par
   54     char character = ' ';\par
   55 \par
   56     switch (op.value)\par
   57     \{\par
   58     case EXT:\par
   59         switch (funct.value)\par
   60         \{\par
   61         case SLL:\par
   62             reg[rd.value] = reg[rt.value] << shamt.value;\par
   63             break;\par
   64 \par
   65         case SRL:\par
   66             if (shamt.value != 0)\par
   67             \{\par
   68                 reg[rd.value] = (reg[rt.value] & 0x7fffffff) >> (shamt.value - 1);\par
   69             \}\par
   70 \par
   71             break;\par
   72 \par
   73         case SRA:\par
   74             if (reg[rt.value] >> 31 == 1)\par
   75             \{\par
   76                 reg[rd.value] = reg[rt.value];\par
   77                 for (i = 0; i < shamt.value; i++)\par
   78                     reg[rd.value] = reg[rd.value] >> 1;\par
   79                 reg[rd.value] = reg[rd.value] | 0x80000000;\par
   80             \}\par
   81             else\par
   82             \{\par
   83                 reg[rd.value] = reg[rt.value] >> shamt.value;\par
   84             \}\par
   85             break;\par
   86 \par
   87         case JR:\par
   88             pc = reg[rs.value];\par
   89             break;\par
   90 \par
   91         case SYSCALL:\par
   92             switch (reg[2])\par
   93             \{\par
   94             case 1:\par
   95                 if (!DEBUG)\par
   96                     printf("%d", reg[4]);\par
   97                 break;\par
   98 \par
   99             case 4:\par
  100                 while (character != '\\0')\par
  101                 \{\par
  102                     if (!DEBUG)\par
  103                         printf("%c", character);\par
  104 \par
  105                     character = lb(reg[4], kte);\par
  106 \par
  107                     kte += 1;\par
  108                 \}\par
  109                 break;\par
  110 \par
  111             case 10:\par
  112                 epc = 1;\par
  113                 break;\par
  114 \par
  115             default:\par
  116                 printf("Invalid syscall");\par
  117                 epc = 2;\par
  118             \}\par
  119             break;\par
  120 \par
  121         case MFHI:\par
  122             reg[rd.value] = hi;\par
  123             break;\par
  124 \par
  125         case MFLO:\par
  126             reg[rd.value] = lo;\par
  127             break;\par
  128 \par
  129         case MULT:\par
  130             product = (int64_t)reg[rs.value] * (int64_t)reg[rt.value];\par
  131             hi = (uint32_t)((product >> 32) & 0xffffffff);\par
  132             lo = (int32_t)product & 0xffffffff;\par
  133             break;\par
  134 \par
  135         case DIV:\par
  136             hi = reg[rs.value] % reg[rt.value];\par
  137             lo = reg[rs.value] / reg[rt.value];\par
  138             break;\par
  139 \par
  140         case ADD:\par
  141             reg[rd.value] = reg[rs.value] + reg[rt.value];\par
  142             break;\par
  143 \par
  144         case ADDU:\par
  145             reg[rd.value] = (uint32_t)reg[rs.value] + reg[rt.value];\par
  146             break;\par
  147 \par
  148         case SUB:\par
  149             reg[rd.value] = reg[rs.value] - reg[rt.value];\par
  150             break;\par
  151 \par
  152         case AND:\par
  153             reg[rd.value] = reg[rs.value] & reg[rt.value];\par
  154             break;\par
  155 \par
  156         case OR:\par
  157             reg[rd.value] = reg[rs.value] | reg[rt.value];\par
  158             break;\par
  159 \par
  160         case XOR:\par
  161             reg[rd.value] = reg[rs.value] ^ reg[rt.value];\par
  162             break;\par
  163 \par
  164         case NOR:\par
  165             reg[rd.value] = ~(reg[rs.value] | reg[rt.value]);\par
  166             break;\par
  167 \par
  168         case SLT:\par
  169             reg[rd.value] = (reg[rs.value] < reg[rt.value]) ? 1 : 0;\par
  170             break;\par
  171 \par
  172         case SLTU:\par
  173             reg[rd.value] = (uint32_t)(reg[rs.value] < reg[rt.value]) ? 1 : 0;\par
  174             break;\par
  175         \}\par
  176         break;\par
  177 \par
  178     case J:\par
  179         pc = (pc & 0xf0000000) | (k26.value << 2);\par
  180         break;\par
  181 \par
  182     case JAL:\par
  183         reg[31] = pc;\par
  184         pc = (pc & 0xf0000000) | (k26.value << 2);\par
  185         break;\par
  186 \par
  187     case BEQ:\par
  188         pc += (reg[rs.value] == reg[rt.value]) ? (k16 << 2) : 0;\par
  189         break;\par
  190 \par
  191     case BNE:\par
  192         pc += (reg[rs.value] != reg[rt.value]) ? (k16 << 2) : 0;\par
  193         break;\par
  194 \par
  195     case BLEZ:\par
  196         pc += (reg[rs.value] <= 0) ? (k16 << 2) : 0;\par
  197         break;\par
  198 \par
  199     case BGTZ:\par
  200         pc += (reg[rs.value] > 0) ? (k16 << 2) : 0;\par
  201         break;\par
  202 \par
  203     case ADDI:\par
  204         reg[rt.value] = reg[rs.value] + k16;\par
  205         break;\par
  206 \par
  207     case ADDIU:\par
  208         reg[rt.value] = (uint32_t)(reg[rs.value] + k16);\par
  209         break;\par
  210 \par
  211     case SLTI:\par
  212         reg[rt.value] = (reg[rs.value] < k16) ? 1 : 0;\par
  213         break;\par
  214 \par
  215     case SLTIU:\par
  216         reg[rt.value] = (((uint32_t)reg[rs.value]) < k16) ? 1 : 0;\par
  217         break;\par
  218 \par
  219     case ANDI:\par
  220         reg[rt.value] = reg[rs.value] & k16;\par
  221         break;\par
  222 \par
  223     case ORI:\par
  224         k16 &= 0x0000ffff;\par
  225         reg[rt.value] = reg[rs.value] | k16;\par
  226         break;\par
  227 \par
  228     case XORI:\par
  229         reg[rt.value] = reg[rs.value] ^ k16;\par
  230         break;\par
  231 \par
  232     case LUI:\par
  233         reg[rt.value] = (int32_t)k16 << 16;\par
  234         break;\par
  235 \par
  236     case LB:\par
  237         reg[rt.value] = lb(reg[rs.value], k16) | 0xffffff00;\par
  238         break;\par
  239 \par
  240     case LH:\par
  241         reg[rt.value] = lh(reg[rs.value], k16) | 0xffff0000;\par
  242         break;\par
  243 \par
  244     case LW:\par
  245         reg[rt.value] = lw(reg[rs.value], k16);\par
  246         break;\par
  247 \par
  248     case LBU:\par
  249         reg[rt.value] = lbu(reg[rs.value], k16);\par
  250         break;\par
  251 \par
  252     case LHU:\par
  253         reg[rt.value] = lhu(reg[rs.value], k16);\par
  254         break;\par
  255 \par
  256     case SB:\par
  257         sb(reg[rs.value], k16, reg[rt.value]);\par
  258         break;\par
  259 \par
  260     case SH:\par
  261         sh(reg[rs.value], k16, reg[rt.value]);\par
  262         break;\par
  263 \par
  264     case SW:\par
  265         sw(reg[rs.value], k16, reg[rt.value]);\par
  266         break;\par
  267 \par
  268     default:\par
  269         printf("Instruction not found\\n");\par
  270         epc = 2;\par
  271         break;\par
  272     \}\par
  273 \}\par
}
}
{\xe \v fetch\:recorder.h}
{\xe \v recorder.h\:fetch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fetch (void )}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registrador. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui s\'E3o definidos os cabe\'E7alhos de todas as fun\'E7\'F5es de registrador\par
Registrador.\par
Esta fun\'E7\'E3o l\'EA uma instru\'E7\'E3o da mem\'F3ria, atribuindo a instru\'E7\'E3o \'E0 ri, e fazendo pc apontar para a pr\'F3xima instru\'E7\'E3o. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     9 \{\par
   10     ri = lw(0, pc);\par
   11     pc += 4;\par
   12 \}\par
}
}
{\xe \v run\:recorder.h}
{\xe \v recorder.h\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void run (void )}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que roda todas as instru\'E7\'F5es da mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o roda todas as intru\'E7\'F5es da mem\'F3ria at\'E9 acabarem as instru\'E7\'F5es, ou o bloco de instru\'E7\'F5es exceder o limite \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int i = 0;\par
  294 \par
  295     if (DEBUG)\par
  296         printf("Pressione enter para pular de instru\'E7\'E3o\\n\\n");\par
  297     while ((epc == 0) && (pc < (MEM_SIZE / 2)))\par
  298     \{\par
  299         step();\par
  300     \}\par
  301 \par
  302     if (epc == 1)\par
  303         printf("\\n\\nSucessfull!!! Closed by syscall\\n");\par
  304     else\par
  305         printf("Error!!! Instruction not found\\n");\par
  306 \}\par
}
}
{\xe \v signal_extension\:recorder.h}
{\xe \v recorder.h\:signal_extension}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void signal_extension (void )}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que estende o sinal de k16. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Por padr\'E3o, k16 \'E9 preenchido com 0's nos primeiros 16 bits e informa\'E7\'E3o nos outros 16 bits. Se o sinal de k16 for negativo, a fun\'E7\'E3o preenche os primeiros 16 bits com 1's, extendendo o sinal negativo. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    38 \{\par
   39     if ((k16 >> 15) == 1)\par
   40         k16 |= 0xffff0000;\par
   41 \}\par
}
}
{\xe \v step\:recorder.h}
{\xe \v recorder.h\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void step (void )}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA, decodifica, executa e debuga cada instru\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o chama outras fun\'E7\'F5es, como um degrau \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279 \{\par
  280     fetch();\par
  281     decode();\par
  282     execute();\par
  283     debug();\par
  284 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/README.md\par \pard\plain 
{\tc\tcl2 \v memory/README.md}
{\xe \v memory/README.md}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/src/global.c\par \pard\plain 
{\tc\tcl2 \v memory/src/global.c}
{\xe \v memory/src/global.c}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/global.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que chama as fun\'E7\'F5es de depura\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug_opcode} (int instruction)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es uteis das instru\'E7\'F5es de opcode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debug_funct} (int instruction)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es \'FAteis de funct. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v debug\:global.c}
{\xe \v global.c\:debug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug (void )}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que chama as fun\'E7\'F5es de depura\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Se op for 0x00, mostra o conte\'FAdo de funct, caso contr\'E1rio, mostra o conte\'FAdo de op. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8 \{\par
    9     if (DEBUG)\par
   10     \{\par
   11         if (op.value == EXT)\par
   12             debug_funct(funct.value);\par
   13         else\par
   14             debug_opcode(op.value);\par
   15 \par
   16         getchar();\par
   17     \}\par
   18 \}\par
}
}
{\xe \v debug_funct\:global.c}
{\xe \v global.c\:debug_funct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug_funct (int  {\i instruction})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es \'FAteis de funct. }}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119 \{\par
  120     switch (instruction)\par
  121     \{\par
  122     case SLL:\par
  123         printf("sll \\t\\t [rd] = \\t d [%d] \\t\\t h [%08x]", rd.value, rd.value);\par
  124         break;\par
  125 \par
  126     case SRL:\par
  127         printf("srl \\t\\t [rd] = \\t d [%d] \\t h [%08x]", rd.value, rd.value);\par
  128         break;\par
  129 \par
  130     case SRA:\par
  131         printf("sra \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  132         break;\par
  133 \par
  134     case JR:\par
  135         printf("sra \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
  136         break;\par
  137 \par
  138     case SYSCALL:\par
  139         printf("syscall \\t reg[2] = \\t d [%d] \\t\\t h [%08x]", reg[2], reg[2]);\par
  140         break;\par
  141 \par
  142     case MFHI:\par
  143         printf("mfhi \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  144         break;\par
  145 \par
  146     case MFLO:\par
  147         printf("mflo \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  148         break;\par
  149 \par
  150     case MULT:\par
  151         printf("mult \\t\\t [hi] = \\t d [%d] \\t h [%08x]\\n", hi, hi);\par
  152         printf("mult \\t\\t [lo] = \\t d [%d] \\t h [%08x]", lo, lo);\par
  153         break;\par
  154 \par
  155     case DIV:\par
  156         printf("div \\t\\t [hi] = \\t d [%d] \\t h [%08x]\\n", hi, hi);\par
  157         printf("div \\t\\t [lo] = \\t d [%d] \\t h [%08x]", lo, lo);\par
  158         break;\par
  159 \par
  160     case ADD:\par
  161         printf("add \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  162         break;\par
  163 \par
  164     case ADDU:\par
  165         printf("addu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  166         break;\par
  167 \par
  168     case SUB:\par
  169         printf("sub \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  170         break;\par
  171 \par
  172     case AND:\par
  173         printf("and \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  174         break;\par
  175 \par
  176     case OR:\par
  177         printf("or \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  178         break;\par
  179 \par
  180     case XOR:\par
  181         printf("xor \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  182         break;\par
  183 \par
  184     case NOR:\par
  185         printf("nor \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  186         break;\par
  187 \par
  188     case SLT:\par
  189         printf("slt \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  190         break;\par
  191 \par
  192     case SLTU:\par
  193         printf("sltu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rd.value, reg[rd.value], reg[rd.value]);\par
  194         break;\par
  195     \}\par
  196 \}\par
}
}
{\xe \v debug_opcode\:global.c}
{\xe \v global.c\:debug_opcode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debug_opcode (int  {\i instruction})}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra informa\'E7\'F5es uteis das instru\'E7\'F5es de opcode. }}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    23 \{\par
   24     switch (instruction)\par
   25     \{\par
   26     case J:\par
   27         printf("j \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   28         break;\par
   29 \par
   30     case JAL:\par
   31         printf("jal \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   32         break;\par
   33 \par
   34     case BEQ:\par
   35         printf("beq \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   36         break;\par
   37 \par
   38     case BNE:\par
   39         printf("bne \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   40         break;\par
   41 \par
   42     case BLEZ:\par
   43         printf("blez \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   44         break;\par
   45 \par
   46     case BGTZ:\par
   47         printf("bgtz \\t\\t [pc] = \\t d [%d] \\t h [%08x]", pc, pc);\par
   48         break;\par
   49 \par
   50     case ADDI:\par
   51         printf("addi \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   52         break;\par
   53 \par
   54     case ADDIU:\par
   55         printf("addiu \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   56         break;\par
   57 \par
   58     case SLTI:\par
   59         printf("slti \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   60         break;\par
   61 \par
   62     case SLTIU:\par
   63         printf("sltiu \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   64         break;\par
   65 \par
   66     case ANDI:\par
   67         printf("andi \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   68         break;\par
   69 \par
   70     case ORI:\par
   71         printf("ori \\t\\t reg[%d] = \\t d [%d] \\t\\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   72         break;\par
   73 \par
   74     case XORI:\par
   75         printf("xori \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   76         break;\par
   77 \par
   78     case LUI:\par
   79         printf("lui \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   80         break;\par
   81 \par
   82     case LB:\par
   83         printf("lb \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   84         break;\par
   85 \par
   86     case LH:\par
   87         printf("lh \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   88         break;\par
   89 \par
   90     case LW:\par
   91         printf("lw \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   92         break;\par
   93 \par
   94     case LBU:\par
   95         printf("lbu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
   96         break;\par
   97 \par
   98     case LHU:\par
   99         printf("lhu \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rt.value, reg[rt.value], reg[rt.value]);\par
  100         break;\par
  101 \par
  102     case SB:\par
  103         printf("sb \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", k16, reg[rt.value], reg[rt.value]);\par
  104         break;\par
  105 \par
  106     case SH:\par
  107         printf("sh \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rs.value, reg[rs.value], reg[rs.value]);\par
  108         break;\par
  109 \par
  110     case SW:\par
  111         printf("sw \\t\\t reg[%d] = \\t d [%d] \\t h [%08x]", rs.value, reg[rs.value], reg[rs.value]);\par
  112         break;\par
  113     \}\par
  114 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/src/init.c\par \pard\plain 
{\tc\tcl2 \v memory/src/init.c}
{\xe \v memory/src/init.c}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/init.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializador. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_variables} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializador de Vari\'E1veis. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_data} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de data.bin. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_text} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de text.bin. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v init\:init.c}
{\xe \v init.c\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init (void )}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializador. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializa\'E7\'E3o.\par
Chama todas as fun\'E7\'F5es de inicializa\'E7\'E3o, que inicializam vari\'E1veis e leem os arquivos text.bin e data.bin. Se DEBUG for true, ele mostra informa\'E7\'F5es dos registradores e da mem\'F3ria {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12 \{\par
   13     init_variables();\par
   14     read_data();\par
   15     read_text();\par
   16     run();\par
   17 \par
   18     if (DEBUG)\par
   19     \{\par
   20         dump_reg('h');\par
   21         dump_reg('d');\par
   22         dump_mem_recorder(0, 72, 'h');\par
   23         printf("\\n");\par
   24         dump_mem_recorder(0, 72, 'd');\par
   25     \}\par
   26 \}\par
}
}
{\xe \v init_variables\:init.c}
{\xe \v init.c\:init_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_variables (void )}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inicializador de Vari\'E1veis. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui s\'E3o setados os valores iniciais de todas as vari\'E1veis globais do projeto {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    35 \{\par
   36     int i;\par
   37 \par
   38     k16 = 0;\par
   39     k26.value = 0;\par
   40     rs.value = 0;\par
   41     rt.value = 0;\par
   42     rd.value = 0;\par
   43     shamt.value = 0;\par
   44     op.value = 0;\par
   45     funct.value = 0;\par
   46     pc = 0;\par
   47     ri = 0;\par
   48     epc = 0;\par
   49     counter = 0;\par
   50 \par
   51     for (i = 0; i < 32; i++)\par
   52         reg[i] = 0;\par
   53 \}\par
}
}
{\xe \v read_data\:init.c}
{\xe \v init.c\:read_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_data (void )}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de data.bin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA os dados do arquivo data.bin para a mem\'F3ria a partir do endere\'E7o (MEM_SIZE / 2) {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    62 \{\par
   63     FILE *data;\par
   64     int i = 0;\par
   65     char lib[] = "../lib/";\par
   66     char bin[] = "/data.bin";\par
   67     char directory[200];\par
   68 \par
   69     strcpy(directory, lib);\par
   70     strcat(directory, DIR);\par
   71     strcat(directory, bin);\par
   72 \par
   73     data = fopen(directory, "rb");\par
   74 \par
   75     if (!data)\par
   76     \{\par
   77         printf("Error reading\\n");\par
   78     \}\par
   79     else\par
   80     \{\par
   81         while (fread(&mem[i + (MEM_SIZE / 2)], 4, 1, data) != 0)\par
   82         \{\par
   83             i++;\par
   84         \}\par
   85     \}\par
   86 \par
   87     fclose(data);\par
   88 \}\par
}
}
{\xe \v read_text\:init.c}
{\xe \v init.c\:read_text}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_text (void )}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Leitor de text.bin. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA os dados do arquivo text.bin para a mem\'F3ria a partir do endere\'E7o 0. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i void} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    97 \{\par
   98     FILE *text;\par
   99     int i = 0;\par
  100     char lib[] = "../lib/";\par
  101     char bin[] = "/text.bin";\par
  102     char directory[200];\par
  103 \par
  104     strcpy(directory, lib);\par
  105     strcat(directory, DIR);\par
  106     strcat(directory, bin);\par
  107 \par
  108     text = fopen(directory, "rb");\par
  109 \par
  110     if (!text)\par
  111     \{\par
  112         printf("Error reading\\n");\par
  113     \}\par
  114     else\par
  115     \{\par
  116         while (fread(&mem[i], 4, 1, text) != 0)\par
  117         \{\par
  118             i++;\par
  119         \}\par
  120     \}\par
  121 \par
  122     fclose(text);\par
  123 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/src/main.c\par \pard\plain 
{\tc\tcl2 \v memory/src/main.c}
{\xe \v memory/src/main.c}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/memory.h"}\par
{\f2 #include "../include/recorder.h"}\par
{\f2 #include "../include/global.h"}\par
{\f2 #include "../include/init.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v main\:main.c}
{\xe \v main.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     7 \{\par
    8     DEBUG = false;\par
    9     strcpy(DIR, "teste");\par
   10 \par
   11     init();\par
   12 \par
   13     return 0;\par
   14 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/src/memory.c\par \pard\plain 
{\tc\tcl2 \v memory/src/memory.c}
{\xe \v memory/src/memory.c}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/memory.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump_mem} (uint32_t address, uint32_t size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra conte\'FAdo da mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b lw} (uint32_t address, int16_t kte)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA uma palavra de 32 bits. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b lh} (uint32_t address, int16_t kte)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lhu} (uint32_t address, int16_t kte)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits sem sinal. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int32_t {\b lb} (uint32_t address, int16_t kte)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lbu} (uint32_t address, int16_t kte)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte sem sinal. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sw} (uint32_t address, int16_t kte, int32_t dado)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva uma palavra de 32 bits na mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sh} (uint32_t address, int16_t kte, int16_t dado)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva meia palavra de 32 bits na mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sb} (uint32_t address, int16_t kte, int8_t dado)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva um byte na mem\'F3ria. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v dump_mem\:memory.c}
{\xe \v memory.c\:dump_mem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dump_mem (uint32_t  {\i address}, uint32_t  {\i size})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra conte\'FAdo da mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mem\'F3ria.\par
Esta fun\'E7\'E3o mostra o conte\'FAdo da mem\'F3ria de um endere\'E7o inicial at\'E9 um endere\'E7o de valor inicial somado a uma constante. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, uint32_t size \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    11 \{\par
   12     int i;\par
   13 \par
   14     for (i = address; i < ((address + size) / 4); i++)\par
   15     \{\par
   16         printf("mem[%d] = %08x\\n", i, mem[i]);\par
   17     \}\par
   18 \}\par
}
}
{\xe \v lb\:memory.c}
{\xe \v memory.c\:lb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t lb (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler o byte Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui o byte lido \'E9 deslocado para o inicio de word\par
Aqui o byte lido \'E9 deslocado para o inicio de word\par
Aqui o byte lido \'E9 deslocado para o inicio de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   157 \{\par
  158     int32_t mask, word, rest;\par
  159 \par
  160     rest = (address + kte) % 4;\par
  161     address = (address + kte) / 4;\par
  162 \par
  163     if (rest == 0)\par
  164     \{\par
  165         mask = 0x000000ff;\par
  166         word = mem[address] & mask;\par
  167         return word;\par
  168     \}\par
  169     else if (rest == 1)\par
  170     \{\par
  171         mask = 0x0000ff00;\par
  172         word = mem[address] & mask;\par
  173 \par
  175         word >>= 4 * 2;\par
  176         return word;\par
  177     \}\par
  178     else if (rest == 2)\par
  179     \{\par
  180         mask = 0x00ff0000;\par
  181         word = mem[address] & mask;\par
  182 \par
  184         word >>= 4 * 4;\par
  185         return word;\par
  186     \}\par
  187     else if (rest == 3)\par
  188     \{\par
  189         mask = 0xff000000;\par
  190         word = mem[address] & mask;\par
  191 \par
  193         word >>= 4 * 6;\par
  194         mask = 0x000000ff;\par
  195         word &= mask;\par
  196         return word;\par
  197     \}\par
  198 \par
  199     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
  200     return 0x4552524F;\par
  201 \}\par
}
}
{\xe \v lbu\:memory.c}
{\xe \v memory.c\:lbu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lbu (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA um byte sem sinal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler o byte Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. O valor retornado pela fun\'E7\'E3o, \'E9 um valor unsigned, ou seja, sem sinal. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui o byte lido \'E9 deslocado para o endere\'E7o inicial de word\par
Aqui o byte lido \'E9 deslocado para o endere\'E7o inicial de word\par
Aqui o byte lido \'E9 deslocado para o endere\'E7o inicial de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   215 \{\par
  216     int32_t mask, word, rest;\par
  217 \par
  218     rest = (address + kte) % 4;\par
  219     address = (address + kte) / 4;\par
  220 \par
  221     if (rest == 0)\par
  222     \{\par
  223         mask = 0x000000ff;\par
  224         word = mem[address] & mask;\par
  225         return word;\par
  226     \}\par
  227     else if (rest == 1)\par
  228     \{\par
  229         mask = 0x0000ff00;\par
  230         word = mem[address] & mask;\par
  231 \par
  233         word >>= 4 * 2;\par
  234         return word;\par
  235     \}\par
  236     else if (rest == 2)\par
  237     \{\par
  238         mask = 0x00ff0000;\par
  239         word = mem[address] & mask;\par
  240 \par
  242         word >>= 4 * 4;\par
  243         return word;\par
  244     \}\par
  245     else if (rest == 3)\par
  246     \{\par
  247         mask = 0xff000000;\par
  248         word = mem[address] & mask;\par
  249 \par
  251         word >>= 4 * 6;\par
  252         mask = 0x000000ff;\par
  253         word &= mask;\par
  254         return word;\par
  255     \}\par
  256 \par
  257     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
  258     return 0x4552524F;\par
  259 \}\par
}
}
{\xe \v lh\:memory.c}
{\xe \v memory.c\:lh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t lh (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 2, a fun\'E7\'E3o mostra uma menssagem de erro e retorna um valor que indica que h\'E1 um erro. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler meia palavra tanto superior, quanto inferior. Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui a meia palavra lida \'E9 deslocada para o endere\'E7o inicial de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{\par
   60     int32_t mask, word, rest;\par
   61 \par
   62     rest = (address + kte) % 4;\par
   63 \par
   64     if (((address + kte) % 2) == 0)\par
   65     \{\par
   66         address = (address + kte) / 4;\par
   67 \par
   68         if (rest == 0)\par
   69         \{\par
   70             mask = 0x0000ffff;\par
   71             word = mem[address] & mask;\par
   72             return word;\par
   73         \}\par
   74         else if (rest == 2)\par
   75         \{\par
   76             mask = 0xffff0000;\par
   77             word = mem[address] & mask;\par
   78 \par
   80             word >>= 4 * 4;\par
   81             mask = 0x0000ffff;\par
   82             word &= mask;\par
   83             return word;\par
   84         \}\par
   85     \}\par
   86     else\par
   87     \{\par
   88         printf("Non-aligned address\\n");\par
   89     \}\par
   90 \par
   91     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
   92     return 0x4552524F;\par
   93 \}\par
}
}
{\xe \v lhu\:memory.c}
{\xe \v memory.c\:lhu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lhu (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA meia palavra de 32 bits sem sinal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 2, a fun\'E7\'E3o mostra uma menssagem de erro e retorna um valor que indica que h\'E1 um erro. A fun\'E7\'E3o utiliza m\'E1scaras para conseguir ler meia palavra tanto superior, quanto inferior. Em seguida, os valores lidos s\'E3o deslocados para o inicio da palavra de retorno. O valor retornado pela fun\'E7\'E3o, \'E9 um valor unsigned, ou seja, sem sinal. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Aqui a meia palavra lida \'E9 deslocada para o endere\'E7o inicial de word \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111 \{\par
  112     uint32_t mask, word, rest;\par
  113 \par
  114     rest = (address + kte) % 4;\par
  115 \par
  116     if (((address + kte) % 2) == 0)\par
  117     \{\par
  118         address = (address + kte) / 4;\par
  119 \par
  120         if (rest == 0)\par
  121         \{\par
  122             mask = 0x0000ffff;\par
  123             word = mem[address] & mask;\par
  124             return word;\par
  125         \}\par
  126         else if (rest == 2)\par
  127         \{\par
  128             mask = 0xffff0000;\par
  129             word = mem[address] & mask;\par
  130 \par
  132             word >>= 4 * 4;\par
  133             mask = 0x0000ffff;\par
  134             word &= mask;\par
  135             return word;\par
  136         \}\par
  137     \}\par
  138     else\par
  139     \{\par
  140         printf("Non-aligned address\\n");\par
  141     \}\par
  142 \par
  143     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
  144     return 0x4552524F;\par
  145 \}\par
}
}
{\xe \v lw\:memory.c}
{\xe \v memory.c\:lw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int32_t lw (uint32_t  {\i address}, int16_t  {\i kte})}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA uma palavra de 32 bits. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o retorna o conte\'FAdo da mem\'F3ria de um endere\'E7o somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 4, a fun\'E7\'E3o mostra uma menssagem de erro e retorna um valor que indica que h\'E1 um erro. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid int32_t mem[address] \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30 \{\par
   31     if (((address + kte) % 4) == 0)\par
   32     \{\par
   33         address = (address + kte) / 4;\par
   34         return mem[address];\par
   35     \}\par
   36     else\par
   37     \{\par
   38         printf("Non-aligned address\\n");\par
   39     \}\par
   40 \par
   41     // ASCII: 45 = E | 52 = R | 52 = R | 4F = O\par
   42     return 0x4552524F;\par
   43 \}\par
}
}
{\xe \v sb\:memory.c}
{\xe \v memory.c\:sb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sb (uint32_t  {\i address}, int16_t  {\i kte}, int8_t  {\i dado})}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva um byte na mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o de mem\'F3ria somado a uma constante. E salva o dado recebido na mem\'F3ria utilizando m\'E1scaras. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte, int32_t dado \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   332 \{\par
  333     int32_t content, mask, word, rest;\par
  334     uint32_t mask_dado;\par
  335 \par
  336     rest = (address + kte) % 4;\par
  337 \par
  338     address = (address + kte) / 4;\par
  339 \par
  340     if (rest == 0)\par
  341     \{\par
  342         mask = 0xffffff00;\par
  343         mask_dado = 0x000000ff;\par
  344         word = mem[address] & mask;\par
  345         content = dado & mask_dado;\par
  346         mem[address] = word | content;\par
  347     \}\par
  348     else if (rest == 1)\par
  349     \{\par
  350         mask = 0xffff00ff;\par
  351         mask_dado = 0x0000ff00;\par
  352         word = mem[address] & mask;\par
  353         content = (dado << 8) & mask_dado;\par
  354         mem[address] = word | content;\par
  355     \}\par
  356     else if (rest == 2)\par
  357     \{\par
  358         mask = 0xff00ffff;\par
  359         mask_dado = 0x00ff0000;\par
  360         word = mem[address] & mask;\par
  361         content = (dado << 16) & mask_dado;\par
  362         mem[address] = word | content;\par
  363     \}\par
  364     else if (rest == 3)\par
  365     \{\par
  366         mask = 0x00ffffff;\par
  367         mask_dado = 0xff000000;\par
  368         word = mem[address] & mask;\par
  369         content = (dado << 24) & mask_dado;\par
  370         mem[address] = word | content;\par
  371     \}\par
  372 \}\par
}
}
{\xe \v sh\:memory.c}
{\xe \v memory.c\:sh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sh (uint32_t  {\i address}, int16_t  {\i kte}, int16_t  {\i dado})}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva meia palavra de 32 bits na mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o de mem\'F3ria somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 2, a fun\'E7\'E3o mostra uma menssagem de erro. Caso contr\'E1rio, ela salva o dado recebido na mem\'F3ria nos limites superior ou inferior do endere\'E7o utilizando m\'E1scaras. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte, int32_t dado \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int32_t content, mask, word, rest;\par
  294     uint32_t mask_dado;\par
  295 \par
  296     rest = (address + kte) % 4;\par
  297 \par
  298     if (((address + kte) % 2) == 0)\par
  299     \{\par
  300         address = (address + kte) / 4;\par
  301 \par
  302         if (rest == 0)\par
  303         \{\par
  304             mask = 0xffff0000;\par
  305             mask_dado = 0x0000ffff;\par
  306             word = mem[address] & mask;\par
  307             content = dado & mask_dado;\par
  308             mem[address] = word | content;\par
  309         \}\par
  310         else if (rest == 2)\par
  311         \{\par
  312             mask = 0x0000ffff;\par
  313             mask_dado = 0xffff0000;\par
  314             word = mem[address] & mask;\par
  315             content = (dado << 16) & mask_dado;\par
  316             mem[address] = word | content;\par
  317         \}\par
  318     \}\par
  319     else\par
  320     \{\par
  321         printf("Non-aligned address\\n");\par
  322     \}\par
  323 \}\par
}
}
{\xe \v sw\:memory.c}
{\xe \v memory.c\:sw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sw (uint32_t  {\i address}, int16_t  {\i kte}, int32_t  {\i dado})}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que salva uma palavra de 32 bits na mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o de mem\'F3ria somado a uma constante. Se o endere\'E7o estiver desalinhado da mem\'F3ria, ou seja n\'E3o for divis\'EDvel por 4, a fun\'E7\'E3o mostra uma menssagem de erro. Caso contr\'E1rio, ela salva o dado recebido na mem\'F3ria {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uint32_t} \cell }{address, int16_t kte, int32_t dado \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid void \par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270 \{\par
  271     if (((address + kte) % 4) == 0)\par
  272     \{\par
  273         address = (address + kte) / 4;\par
  274         mem[address] = dado;\par
  275     \}\par
  276     else\par
  277     \{\par
  278         printf("Non-aligned address\\n");\par
  279     \}\par
  280 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro memory/src/recorder.c\par \pard\plain 
{\tc\tcl2 \v memory/src/recorder.c}
{\xe \v memory/src/recorder.c}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/recorder.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fetch} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA palavra da mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b decode} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que decodifica uma instru\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b signal_extension} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que estende o sinal de k16. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b execute} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que executa as instru\'E7\'F5es de opcode e funct. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b step} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA, decodifica, executa e debuga cada instru\'E7\'E3o. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que roda todas as instru\'E7\'F5es da mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump_mem_recorder} (int start, int end, char format)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra conte\'FAdo da mem\'F3ria. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump_reg} (char format)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra o conte\'FAdo dos registradores. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v decode\:recorder.c}
{\xe \v recorder.c\:decode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void decode (void )}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que decodifica uma instru\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o faz uso do registrador ri, atribuindo cada parte da instru\'E7\'E3o contida em ri, em um campo \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19 \{\par
   20     op.value = (ri >> 26) & 0x3f;\par
   21     rs.value = (ri >> 21) & 0x1f;\par
   22     rt.value = (ri >> 16) & 0x1f;\par
   23     rd.value = (ri >> 11) & 0x1f;\par
   24     shamt.value = (ri >> 6) & 0x1f;\par
   25     funct.value = ri & 0x3f;\par
   26     k26.value = ri & 0x3ffffff;\par
   27     k16 = ri & 0xffff;\par
   28     signal_extension();\par
   29 \}\par
}
}
{\xe \v dump_mem_recorder\:recorder.c}
{\xe \v recorder.c\:dump_mem_recorder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dump_mem_recorder (int  {\i start}, int  {\i end}, char  {\i format})}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra conte\'FAdo da mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o recebe um endere\'E7o inicial, e um endere\'E7o final e mostra o conte\'FAdo da mem\'F3ria contido nestes endere\'E7os nos formatos hexadecimal ou decimal {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{start, int end, char format \cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315 \{\par
  316     int i;\par
  317 \par
  318     if (start < end && ((start + end) % 4) == 0)\par
  319     \{\par
  320         if (format == 'h')\par
  321         \{\par
  322             for (i = start / 4; i < end / 4; i++)\par
  323             \{\par
  324                 printf("mem[%d] =\\t\\t %08x\\n", i, mem[i]);\par
  325             \}\par
  326         \}\par
  327         else if (format == 'd')\par
  328         \{\par
  329             for (i = start / 4; i < end / 4; i++)\par
  330             \{\par
  331                 printf("mem[%d] =\\t\\t %d\\n", i, mem[i]);\par
  332             \}\par
  333         \}\par
  334         else\par
  335         \{\par
  336             printf("Invalid Format\\n");\par
  337         \}\par
  338     \}\par
  339     else\par
  340     \{\par
  341         printf("Non-aligned address\\n");\par
  342     \}\par
  343 \}\par
}
}
{\xe \v dump_reg\:recorder.c}
{\xe \v recorder.c\:dump_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dump_reg (char  {\i format})}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que mostra o conte\'FAdo dos registradores. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o percorre todos os registradores, mostrando o conte\'FAdo de cada um {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i char} \cell }{format \cell }
{\row }
}
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   351 \{\par
  352     int i;\par
  353 \par
  354     if (format == 'h')\par
  355     \{\par
  356         printf("\\nregister ($zero):\\t %08x\\n", reg[0]);\par
  357         printf("register ($at):\\t\\t %08x\\n", reg[1]);\par
  358         printf("register ($v0):\\t\\t %08x\\n", reg[2]);\par
  359         printf("register ($v1):\\t\\t %08x\\n", reg[3]);\par
  360 \par
  361         for (i = 4; i < 8; i++)\par
  362             printf("register ($a%d):\\t\\t %08x\\n", (i - 4), reg[i]);\par
  363         for (i = 8; i < 16; i++)\par
  364             printf("register ($t%d):\\t\\t %08x\\n", (i - 8), reg[i]);\par
  365         for (i = 16; i < 26; i++)\par
  366             printf("register ($s%d):\\t\\t %08x\\n", (i - 16), reg[i]);\par
  367 \par
  368         printf("register ($k0):\\t\\t %08x\\n", reg[26]);\par
  369         printf("register ($k1):\\t\\t %08x\\n", reg[27]);\par
  370         printf("register ($gp):\\t\\t %08x\\n", reg[28]);\par
  371         printf("register ($sp):\\t\\t %08x\\n", reg[29]);\par
  372         printf("register ($fp):\\t\\t %08x\\n", reg[30]);\par
  373         printf("register ($ra):\\t\\t %08x\\n", reg[31]);\par
  374         printf("register (pc):\\t\\t %08x\\n", pc);\par
  375         printf("register (hi):\\t\\t %08x\\n", hi);\par
  376         printf("register (lo):\\t\\t %08x\\n\\n", lo);\par
  377         printf("rs.value:\\t\\t %08x\\n", rs.value);\par
  378         printf("rt.value:\\t\\t %08x\\n", rt.value);\par
  379         printf("rd.value:\\t\\t %08x\\n", rd.value);\par
  380         printf("shamt:\\t\\t\\t %08x\\n", shamt.value);\par
  381         printf("op:\\t\\t\\t %08x\\n", op.value);\par
  382         printf("funct:\\t\\t\\t %08x\\n", funct.value);\par
  383         printf("k16:\\t\\t\\t %08x\\n", k16);\par
  384         printf("k26:\\t\\t\\t %08x\\n\\n", k26);\par
  385     \}\par
  386     else if (format == 'd')\par
  387     \{\par
  388         printf("\\nregister ($zero):\\t %d\\n", reg[0]);\par
  389         printf("register ($at):\\t\\t %d\\n", reg[1]);\par
  390         printf("register ($v0):\\t\\t %d\\n", reg[2]);\par
  391         printf("register ($v1):\\t\\t %d\\n", reg[3]);\par
  392 \par
  393         for (i = 4; i < 8; i++)\par
  394             printf("register ($a%d):\\t\\t %d\\n", (i - 4), reg[i]);\par
  395         for (i = 8; i < 16; i++)\par
  396             printf("register ($t%d):\\t\\t %d\\n", (i - 8), reg[i]);\par
  397         for (i = 16; i < 26; i++)\par
  398             printf("register ($s%d):\\t\\t %d\\n", (i - 16), reg[i]);\par
  399 \par
  400         printf("register ($k0):\\t\\t %d\\n", reg[26]);\par
  401         printf("register ($k1):\\t\\t %d\\n", reg[27]);\par
  402         printf("register ($gp):\\t\\t %d\\n", reg[28]);\par
  403         printf("register ($sp):\\t\\t %d\\n", reg[29]);\par
  404         printf("register ($fp):\\t\\t %d\\n", reg[30]);\par
  405         printf("register ($ra):\\t\\t %d\\n", reg[31]);\par
  406         printf("register (pc):\\t\\t %d\\n", pc);\par
  407         printf("register (hi):\\t\\t %d\\n", hi);\par
  408         printf("register (lo):\\t\\t %d\\n\\n", lo);\par
  409     \}\par
  410     else\par
  411     \{\par
  412         printf("Invalid Format\\n");\par
  413     \}\par
  414 \}\par
}
}
{\xe \v execute\:recorder.c}
{\xe \v recorder.c\:execute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void execute (void )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que executa as instru\'E7\'F5es de opcode e funct. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Depois de lidas e decodificadas as instru\'E7\'F5es do registrador de instru\'E7\'F5es (ri), os comandos opcode e funct s\'E3o avaliados e selecionados para executar os comandos da instru\'E7\'E3o \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    50 \{\par
   51     int64_t product;\par
   52     uint16_t kte = 0;\par
   53     int i;\par
   54     char character = ' ';\par
   55 \par
   56     switch (op.value)\par
   57     \{\par
   58     case EXT:\par
   59         switch (funct.value)\par
   60         \{\par
   61         case SLL:\par
   62             reg[rd.value] = reg[rt.value] << shamt.value;\par
   63             break;\par
   64 \par
   65         case SRL:\par
   66             if (shamt.value != 0)\par
   67             \{\par
   68                 reg[rd.value] = (reg[rt.value] & 0x7fffffff) >> (shamt.value - 1);\par
   69             \}\par
   70 \par
   71             break;\par
   72 \par
   73         case SRA:\par
   74             if (reg[rt.value] >> 31 == 1)\par
   75             \{\par
   76                 reg[rd.value] = reg[rt.value];\par
   77                 for (i = 0; i < shamt.value; i++)\par
   78                     reg[rd.value] = reg[rd.value] >> 1;\par
   79                 reg[rd.value] = reg[rd.value] | 0x80000000;\par
   80             \}\par
   81             else\par
   82             \{\par
   83                 reg[rd.value] = reg[rt.value] >> shamt.value;\par
   84             \}\par
   85             break;\par
   86 \par
   87         case JR:\par
   88             pc = reg[rs.value];\par
   89             break;\par
   90 \par
   91         case SYSCALL:\par
   92             switch (reg[2])\par
   93             \{\par
   94             case 1:\par
   95                 if (!DEBUG)\par
   96                     printf("%d", reg[4]);\par
   97                 break;\par
   98 \par
   99             case 4:\par
  100                 while (character != '\\0')\par
  101                 \{\par
  102                     if (!DEBUG)\par
  103                         printf("%c", character);\par
  104 \par
  105                     character = lb(reg[4], kte);\par
  106 \par
  107                     kte += 1;\par
  108                 \}\par
  109                 break;\par
  110 \par
  111             case 10:\par
  112                 epc = 1;\par
  113                 break;\par
  114 \par
  115             default:\par
  116                 printf("Invalid syscall");\par
  117                 epc = 2;\par
  118             \}\par
  119             break;\par
  120 \par
  121         case MFHI:\par
  122             reg[rd.value] = hi;\par
  123             break;\par
  124 \par
  125         case MFLO:\par
  126             reg[rd.value] = lo;\par
  127             break;\par
  128 \par
  129         case MULT:\par
  130             product = (int64_t)reg[rs.value] * (int64_t)reg[rt.value];\par
  131             hi = (uint32_t)((product >> 32) & 0xffffffff);\par
  132             lo = (int32_t)product & 0xffffffff;\par
  133             break;\par
  134 \par
  135         case DIV:\par
  136             hi = reg[rs.value] % reg[rt.value];\par
  137             lo = reg[rs.value] / reg[rt.value];\par
  138             break;\par
  139 \par
  140         case ADD:\par
  141             reg[rd.value] = reg[rs.value] + reg[rt.value];\par
  142             break;\par
  143 \par
  144         case ADDU:\par
  145             reg[rd.value] = (uint32_t)reg[rs.value] + reg[rt.value];\par
  146             break;\par
  147 \par
  148         case SUB:\par
  149             reg[rd.value] = reg[rs.value] - reg[rt.value];\par
  150             break;\par
  151 \par
  152         case AND:\par
  153             reg[rd.value] = reg[rs.value] & reg[rt.value];\par
  154             break;\par
  155 \par
  156         case OR:\par
  157             reg[rd.value] = reg[rs.value] | reg[rt.value];\par
  158             break;\par
  159 \par
  160         case XOR:\par
  161             reg[rd.value] = reg[rs.value] ^ reg[rt.value];\par
  162             break;\par
  163 \par
  164         case NOR:\par
  165             reg[rd.value] = ~(reg[rs.value] | reg[rt.value]);\par
  166             break;\par
  167 \par
  168         case SLT:\par
  169             reg[rd.value] = (reg[rs.value] < reg[rt.value]) ? 1 : 0;\par
  170             break;\par
  171 \par
  172         case SLTU:\par
  173             reg[rd.value] = (uint32_t)(reg[rs.value] < reg[rt.value]) ? 1 : 0;\par
  174             break;\par
  175         \}\par
  176         break;\par
  177 \par
  178     case J:\par
  179         pc = (pc & 0xf0000000) | (k26.value << 2);\par
  180         break;\par
  181 \par
  182     case JAL:\par
  183         reg[31] = pc;\par
  184         pc = (pc & 0xf0000000) | (k26.value << 2);\par
  185         break;\par
  186 \par
  187     case BEQ:\par
  188         pc += (reg[rs.value] == reg[rt.value]) ? (k16 << 2) : 0;\par
  189         break;\par
  190 \par
  191     case BNE:\par
  192         pc += (reg[rs.value] != reg[rt.value]) ? (k16 << 2) : 0;\par
  193         break;\par
  194 \par
  195     case BLEZ:\par
  196         pc += (reg[rs.value] <= 0) ? (k16 << 2) : 0;\par
  197         break;\par
  198 \par
  199     case BGTZ:\par
  200         pc += (reg[rs.value] > 0) ? (k16 << 2) : 0;\par
  201         break;\par
  202 \par
  203     case ADDI:\par
  204         reg[rt.value] = reg[rs.value] + k16;\par
  205         break;\par
  206 \par
  207     case ADDIU:\par
  208         reg[rt.value] = (uint32_t)(reg[rs.value] + k16);\par
  209         break;\par
  210 \par
  211     case SLTI:\par
  212         reg[rt.value] = (reg[rs.value] < k16) ? 1 : 0;\par
  213         break;\par
  214 \par
  215     case SLTIU:\par
  216         reg[rt.value] = (((uint32_t)reg[rs.value]) < k16) ? 1 : 0;\par
  217         break;\par
  218 \par
  219     case ANDI:\par
  220         reg[rt.value] = reg[rs.value] & k16;\par
  221         break;\par
  222 \par
  223     case ORI:\par
  224         k16 &= 0x0000ffff;\par
  225         reg[rt.value] = reg[rs.value] | k16;\par
  226         break;\par
  227 \par
  228     case XORI:\par
  229         reg[rt.value] = reg[rs.value] ^ k16;\par
  230         break;\par
  231 \par
  232     case LUI:\par
  233         reg[rt.value] = (int32_t)k16 << 16;\par
  234         break;\par
  235 \par
  236     case LB:\par
  237         reg[rt.value] = lb(reg[rs.value], k16) | 0xffffff00;\par
  238         break;\par
  239 \par
  240     case LH:\par
  241         reg[rt.value] = lh(reg[rs.value], k16) | 0xffff0000;\par
  242         break;\par
  243 \par
  244     case LW:\par
  245         reg[rt.value] = lw(reg[rs.value], k16);\par
  246         break;\par
  247 \par
  248     case LBU:\par
  249         reg[rt.value] = lbu(reg[rs.value], k16);\par
  250         break;\par
  251 \par
  252     case LHU:\par
  253         reg[rt.value] = lhu(reg[rs.value], k16);\par
  254         break;\par
  255 \par
  256     case SB:\par
  257         sb(reg[rs.value], k16, reg[rt.value]);\par
  258         break;\par
  259 \par
  260     case SH:\par
  261         sh(reg[rs.value], k16, reg[rt.value]);\par
  262         break;\par
  263 \par
  264     case SW:\par
  265         sw(reg[rs.value], k16, reg[rt.value]);\par
  266         break;\par
  267 \par
  268     default:\par
  269         printf("Instruction not found\\n");\par
  270         epc = 2;\par
  271         break;\par
  272     \}\par
  273 \}\par
}
}
{\xe \v fetch\:recorder.c}
{\xe \v recorder.c\:fetch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fetch (void )}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA palavra da mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Registrador.\par
Esta fun\'E7\'E3o l\'EA uma instru\'E7\'E3o da mem\'F3ria, atribuindo a instru\'E7\'E3o \'E0 ri, e fazendo pc apontar para a pr\'F3xima instru\'E7\'E3o. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     9 \{\par
   10     ri = lw(0, pc);\par
   11     pc += 4;\par
   12 \}\par
}
}
{\xe \v run\:recorder.c}
{\xe \v recorder.c\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void run (void )}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que roda todas as instru\'E7\'F5es da mem\'F3ria. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o roda todas as intru\'E7\'F5es da mem\'F3ria at\'E9 acabarem as instru\'E7\'F5es, ou o bloco de instru\'E7\'F5es exceder o limite \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   292 \{\par
  293     int i = 0;\par
  294 \par
  295     if (DEBUG)\par
  296         printf("Pressione enter para pular de instru\'E7\'E3o\\n\\n");\par
  297     while ((epc == 0) && (pc < (MEM_SIZE / 2)))\par
  298     \{\par
  299         step();\par
  300     \}\par
  301 \par
  302     if (epc == 1)\par
  303         printf("\\n\\nSucessfull!!! Closed by syscall\\n");\par
  304     else\par
  305         printf("Error!!! Instruction not found\\n");\par
  306 \}\par
}
}
{\xe \v signal_extension\:recorder.c}
{\xe \v recorder.c\:signal_extension}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void signal_extension (void )}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que estende o sinal de k16. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Por padr\'E3o, k16 \'E9 preenchido com 0's nos primeiros 16 bits e informa\'E7\'E3o nos outros 16 bits. Se o sinal de k16 for negativo, a fun\'E7\'E3o preenche os primeiros 16 bits com 1's, extendendo o sinal negativo. \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    38 \{\par
   39     if ((k16 >> 15) == 1)\par
   40         k16 |= 0xffff0000;\par
   41 \}\par
}
}
{\xe \v step\:recorder.c}
{\xe \v recorder.c\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void step (void )}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fun\'E7\'E3o que l\'EA, decodifica, executa e debuga cada instru\'E7\'E3o. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Esta fun\'E7\'E3o chama outras fun\'E7\'F5es, como um degrau \par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   279 \{\par
  280     fetch();\par
  281     decode();\par
  282     execute();\par
  283     debug();\par
  284 \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par 
\pard\plain 
{\tc \v \'CDndice}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}